<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>YOLO Object Detection</title>
<style>
body {
    margin:0;
    font-family:'Segoe UI',sans-serif;
    background:#f5f5f5;
    color:#222;
}
header {
    padding:20px;
    /* text-align:center; */
    background:#fff;
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
}
h2 { margin:0; }

.container {
    display:flex;
    padding:20px;
    gap:20px;
}

#videoContainer {
    position:relative;
    height:700px;
    /* background:#000; */
    border-radius:8px;
    overflow:hidden;
}

#video {
    width:100%;
    height:100%;
    object-fit:contain;
}

#overlay {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
}

/* draggable lines */
.line {
    position:absolute;
    left:0;
    width:100%;
    height:3px;
    cursor:ns-resize;
    z-index:5;
}
#lineA {
    background:red;
    top:300px;
}
#lineB {
    background:blue;
    top:400px;
}
.line-label {
    position:absolute;
    left:10px;
    color:white;
    font-weight:bold;
    font-size:13px;
    text-shadow:0 0 3px black;
    pointer-events:none;
}

.rightBar {
    width: 350px;
    background:#fff;
    border-radius:8px;
    /* padding:15px; */
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
    display:flex;
    flex-direction:column;
    gap:15px;
}

.rightBar > div {
  padding: 0 15px;
}

.rightBar > *:first-child,
.rightBar > *:last-child {
  padding: 15px;
}

input[type=range] { width:-webkit-fill-available; }
label { font-size:14px;font-weight:600; }

#progressBar {
    width:100%;
    height:12px;
    background:#ddd;
    border-radius:6px;
    overflow:hidden;
    margin:10px 0;
}
#progressFill {
    height:100%;
    width:0;
    background:#4caf50;
    transition:width 0.2s;
}

button {
    padding:8px 12px;
    background:#4caf50;
    color:white;
    border:none;
    border-radius:4px;
    cursor:pointer;
}
button:hover { background:#45a049; }

input[type=text], input[type=number] {
    width:100%;
    padding:6px;
    border:1px solid #ccc;
    border-radius:4px;
}
</style>

<style>
/* --- Crossing list UI --- */
#crossingList, #plateList {
    list-style: none;        /* Remove bullets */
    padding: 0;              /* Remove default padding */
    margin: 0;               /* Remove default margin */
    max-height: 200px;       /* Scrollable if too long */
    overflow-y: auto;
    font-family: monospace;  /* Fixed-width for numbers */
    background: #fff;        /* White background */
    border: 1px solid #ccc;  /* Light border */
    border-radius: 6px;
    padding: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#crossingList li, #plateList li {
    padding: 4px 6px;
    border-bottom: 1px solid #eee;
    font-size: 13px;
}

#crossingList li:last-child {
    border-bottom: none; /* Remove bottom border on last item */
}





/* --- Styled file input button --- */
.file-btn {
    display: inline-block;
    padding: 8px 15px;
    background: #4caf50;
    color: white;
    font-weight: 600;
    border-radius: 6px;
    cursor: pointer;
    text-align: center;
    transition: background 0.2s;
}
.file-btn:hover {
    background: #45a049;
}
.file-btn:active {
    background: #3e8e41;
}


</style>

</head>
<body>
<header>
    <h2>YOLO Detection</h2>
    <!-- <a href='/static/replay.html'>open processed files</a> -->
</header>
<!-- <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script> -->
<script src="/static/papaparse.min.js"></script>

<div class="container" style="height: calc(100vh - 8rem);">
    <div style="flex:1;display:flex;flex-direction:column;height: 100%;overflow: auto;">
        <div id="videoContainer" style="flex-shrink: 0;">
            <video id="video" controls></video>
            <canvas id="overlay"></canvas>

            <!-- Draggable lines -->
            <div id="lineA" class="line"><span class="line-label"></span></div>
            <div id="lineB" class="line"><span class="line-label"></span></div>
        </div>

        <div style="padding:1.5rem;">
            <div id="progressBar" style="display: none;"><div id="progressFill"></div></div>
            <p id="statusText" style="display: none;">Waiting for upload...</p>
        </div>

        <!-- <div style="flex-shrink: 0;height: 30rem;background-color: #3e8e41;">
            Automation trigger
        </div> -->
    </div>

    <div class="rightBar" style="overflow: auto;">

        <div>
            <label for="exampleEl">Example</label>
            <select id="exampleEl" style="padding: .5rem;width: 100%;height: 2.5rem;">
                <option value="NumberPlateDetHighway">Number Plate Detection Highway</option>
                <option value="SpeedDetectionHighway">Speed Detection Highway</option>
                <option value="person">Person Detection</option>
                <option value="ObjDetNight">Object Detection In Night</option>
            </select>
        </div>

         <div>
            <label for="confSlider">Confidence Threshold: <span id="confValue">0.5</span></label>
            <input type="range" id="confSlider" min="0" max="1" step="0.05" value="0.5">
        </div>

        <div>
            <label for="classFilter">Filter Classes (comma-separated)</label>
            <input type="text" id="classFilter" placeholder="person,car,bike">
        </div>

        <div>
            <label for="lineDistance">Distance between lines (meters)</label>
            <input type="number" id="lineDistance" value="10" min="0" step="0.1" placeholder="e.g. 5">
        </div>

        <div>
            <input type="checkbox" id="showPlates">
            <label for="showPlates">Detect License Plate</label>
        </div>

        <div>
            <input type="checkbox" id="showLines" checked>
            <label for="showLines">Show refference lines (draggable)</label>
        </div>

        <div>
            <input type="checkbox" id="showTracking" >
            <label for="showTracking">Show object tracking</label>
        </div>


        <div>
            <input type="checkbox" id="blurSourceVideo" >
            <label for="blurSourceVideo">Blur source video</label>
        </div>
        <div>
            <input type="checkbox" id="hideBoundingBox" >
            <label for="hideBoundingBox">Hide bounding box</label>
        </div>



        <div style="margin-top:15px;">
            <h3>Line crossing</h3>
            <ul id="crossingList" style="list-style:none; padding:0; max-height:200px; overflow-y:auto; font-family:monospace;"></ul>
        </div>


        <div style="margin-top:15px;">
            <h3>Events</h3>
            <ul id="plateList" style="list-style:none; padding:0; max-height:200px; overflow-y:auto; font-family:monospace;"></ul>
        </div>


        <div style="
        justify-content: end;
        background: inherit;
            margin-top: auto;
            position: sticky;
            bottom: 0;
            display: none;
            gap: 1rem;">
            <label for="fileInput" class="file-btn">Select Video</label>
            <input type="file" id="fileInput" accept="video/*" style="display:none">
            <button id="uploadBtn">Upload Video</button>


            <button id="downloadBtn">Download Processed data</button>
        </div>


        

    </div>
</div>



<script>
const $ = id => document.getElementById(id);
const exampleEl = $('exampleEl');
const hash = window.location.hash.substring(1);
const hashData = new URLSearchParams(hash)
let example = hashData.get('example') || 'NumberPlateDetHighway'

exampleEl.value = example
$('showLines').checked = hashData.get('showLines') == 'on'
$('confSlider').value = hashData.get('confSlider') || '0.5'
$('confValue').innerText = $('confSlider').value

function setHashParams(params, replace = false) {
  const newHash = new URLSearchParams(params).toString();
  const newUrl = `${window.location.pathname}#${newHash}`;

  if (replace) {
    history.replaceState(null, "", newUrl); // updates URL silently
  } else {
    history.pushState(null, "", newUrl); // adds to history stack
  }
}


$('confSlider').onchange = () => {
    hashData.set('confSlider', $('confSlider').value)
    $('confValue').innerText = $('confSlider').value
    setHashParams(hashData, true)
}
exampleEl.onchange = () => {
    hashData.set('example', exampleEl.value)
    example = exampleEl.value || example
    setHashParams(hashData, true)
    preload()
}

$('blurSourceVideo').onchange = () => {
    $('video').style.opacity = $('blurSourceVideo').checked  ? '0.3' : '1'
}

document.getElementById("downloadBtn").addEventListener("click", async () => {
  try {
    const response = await fetch(`/uploads/detections-${example}.csv`, {
      method: "GET",
    });

    if (!response.ok) {
      const errorData = await response.json();
      alert(errorData.error || "Download failed.");
      return;
    }

    // Get the filename from the response headers (if set)
    const disposition = response.headers.get("Content-Disposition");
    let filename = `data.csv`;
    if (disposition && disposition.includes("filename=")) {
      filename = disposition.split("filename=")[1].replace(/["']/g, "");
    }

    // Convert to blob and trigger a download
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    window.URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Download error:", err);
    alert("Something went wrong while downloading the file.");
  }
});
</script>


<script>
const fileInput = document.getElementById("fileInput");
const uploadBtn = document.getElementById("uploadBtn");
const progressFill = document.getElementById("progressFill");
const statusText = document.getElementById("statusText");
const video = document.getElementById("video");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");

const confSlider = document.getElementById("confSlider");
const confValue = document.getElementById("confValue");
const classFilter = document.getElementById("classFilter");
const lineA = document.getElementById("lineA");
const lineB = document.getElementById("lineB");
const lineDistanceInput = document.getElementById("lineDistance");
const showPlatesCheckbox = document.getElementById("showPlates");
const showLinesCheckbox = document.getElementById("showLines");
const showTrackingEl = document.getElementById("showTracking");
const hideBoundingBoxEl = document.getElementById("hideBoundingBox");



lineA.style.top = '400px'
lineB.style.top = '500px'

let csvData = {};
let plateData = {};
let plateNumberData = {};
let platesMemo = {};
let carPlateMap = {};
let processedFrames = 0;
let totalFrames = 0;
let processedTimeLimit = 0;
let filterConf = parseFloat(confSlider.value);
let filterClasses = [];
let trackingLines = {};

let objectTracks = {};  // store crossing data and speeds
let listed = new Set();

confSlider.oninput = () => {
    filterConf = parseFloat(confSlider.value);
    confValue.innerText = filterConf.toFixed(2);
};
classFilter.oninput = () => {
    filterClasses = classFilter.value.split(",").map(s=>s.trim()).filter(Boolean);
};


uploadBtn.style.display = 'none'
fileInput.onchange = () => {
    uploadBtn.click()
}


lineA.style.display = showLinesCheckbox.checked ? 'block' : 'none'
lineB.style.display = showLinesCheckbox.checked ? 'block' : 'none'
showLinesCheckbox.onchange = () => {
    hashData.set('showLines', showLinesCheckbox.checked ? 'on' : 'off')
    setHashParams(hashData, true)

    if(showLinesCheckbox.checked) {
        lineA.style.display = 'block'
        lineB.style.display = 'block'
    } else {
        lineA.style.display = 'none'
        lineB.style.display = 'none'
    }
}



function processData(data) {
    if(data && data.length>0) {
        for(const d of data) {
            switch(d.class) {
                case 'text':
                    plateNumberData[d.parent] = plateNumberData[d.parent] || []
                    plateNumberData[d.parent].push(d)
                    let newPlate = d
                    
                    if(!carPlateMap[d.parent]) carPlateMap[d.parent] = newPlate
                    if(newPlate.confidence > carPlateMap[d.parent].confidence) carPlateMap[d.parent] = newPlate
                    
                    break
                
                case 'number_plate':
                    plateData[d.frame] = plateData[d.frame] || []
                    plateData[d.frame].push(d)
                    break

                default:
                    csvData[d.frame] = csvData[d.frame] || []
                    csvData[d.frame].push(d)
            }
        }
    }
}


uploadBtn.onclick = async () => {
    plateList.innerText = ''
    crossingList.innerText = ''
    const file = fileInput.files[0];
    if(!file){ alert("Select a video first"); return; }
    const formData = new FormData();
    formData.append("video", file);

    statusText.style.display = 'block'
    $("progressBar").style.display = 'block'

    statusText.innerText = "Uploading and processing...";
    await fetch("/upload", { method:"POST", body: formData });
    loadVideo();
    const eventSource = new EventSource("/progress");
    csvData = {}
    plateData = {}
    plateNumberData = {}
    platesMemo = {}
    carPlateMap = {}
    trackingLines = {}
    eventSource.onmessage = (e) => {
        const data = JSON.parse(e.data);
        const { frame, total, done, percent, new_data } = data;
        totalFrames = total || totalFrames;
        processedFrames = frame;
        progressFill.style.width = percent + "%";
        statusText.innerText = `Processing frame ${frame}/${total}`;
        if(video.duration && totalFrames){
            processedTimeLimit = (processedFrames / totalFrames) * video.duration;
        }

        processData(data.new_data)

        if(done){
            statusText.innerText = "Processing complete!";
            eventSource.close();
        }
    }
};

function loadVideo(){
    video.src = URL.createObjectURL(fileInput.files[0]);
    function resizeCanvas(){
        canvas.width = video.clientWidth;
        canvas.height = video.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    video.addEventListener("timeupdate", ()=>{
        if(video.currentTime > processedTimeLimit){
            video.pause();
            video.currentTime = processedTimeLimit;
            statusText.innerText = "Only processed portion is viewable.";
        }
    });
    video.addEventListener("seeked", () => {trackingLines = {}; drawOverlay()});
    video.addEventListener("play", ()=>requestAnimationFrame(drawOverlay));
    video.addEventListener("pause", drawOverlay);
}

// === Draggable line logic ===
let dragging = null;
let container = document.getElementById("videoContainer");
[lineA,lineB].forEach(line=>{
    line.addEventListener("mousedown", e=>{
        dragging = line;
        document.body.style.userSelect = "none";
    });
});
window.addEventListener("mousemove", e=>{
    if(!dragging) return;
    const rect = container.getBoundingClientRect();
    let newY = e.clientY - rect.top;
    newY = Math.max(0, Math.min(rect.height, newY));
    dragging.style.top = newY + "px";
});
window.addEventListener("mouseup", ()=>{
    dragging = null;
    document.body.style.userSelect = "auto";
});


async function loadCSV(url) {
  const text = await fetch(url).then(r => r.text());
  const { data } = Papa.parse(text, { header: true, skipEmptyLines: true });
  return data;
}

async function preload() {
    const filename = example 
    const data = await loadCSV(`/uploads/detections-${filename}.csv`);
    video.src = `/uploads/${filename}.mp4`
    video.load();
    // console.log(data);
    plateList.innerText = ''
    crossingList.innerText = ''
    processedTimeLimit = data.length
    csvData = {}
    plateData = {}
    plateNumberData = {}
    platesMemo = {}
    carPlateMap = {}
    trackingLines = {}

    processData(data)

    function resizeCanvas(){
        canvas.width = video.clientWidth;
        canvas.height = video.clientHeight;
    }
    resizeCanvas();

    // FIXME: should register only once
    window.addEventListener('resize', resizeCanvas);

    video.addEventListener("timeupdate", ()=>{
        if(video.currentTime > processedTimeLimit){
            video.pause();
            video.currentTime = processedTimeLimit;
            statusText.innerText = "Only processed portion is viewable.";
        }
    });
    video.addEventListener("seeked", drawOverlay);
    video.addEventListener("play", ()=>requestAnimationFrame(drawOverlay));
    video.addEventListener("pause", drawOverlay);
}

preload()

function drawLine(ctx, points, options = {}) {
  if (!ctx || !points?.length) return;

  // Set default options
  const {
    color = '#007bff',
    width = 2,
    close = false // if true, connects last point to first
  } = options;

  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = width;

  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }

  if (close) ctx.closePath();
  ctx.stroke();
}


function drawOverlay() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!csvData || Object.keys(csvData).length === 0) return;

    const allFrameIds = Object.keys(csvData).map(Number);
    const totalFramesLocal = Math.max(...allFrameIds);
    const fps = totalFramesLocal / video.duration;

    const approxFrame = Math.floor(video.currentTime * fps);
    const nearestFrame = allFrameIds.reduce((prev, curr) =>
        Math.abs(curr - approxFrame) < Math.abs(prev - approxFrame) ? curr : prev
    );

    const dets = csvData[nearestFrame];
    if (!dets) return;

    const lineAY = parseFloat(lineA.style.top);
    const lineBY = parseFloat(lineB.style.top);
    const lineDistMeters = parseFloat(lineDistanceInput.value) || 0;

    // Compute scaling between video and displayed size
    const videoAspect = video.videoWidth / video.videoHeight;
    const containerAspect = video.clientWidth / video.clientHeight;
    let scaleX, scaleY, offsetX = 0, offsetY = 0;
    if (videoAspect > containerAspect) {
        scaleX = video.clientWidth / video.videoWidth;
        scaleY = scaleX;
        offsetY = (video.clientHeight - video.videoHeight * scaleY) / 2;
    } else {
        scaleY = video.clientHeight / video.videoHeight;
        scaleX = scaleY;
        offsetX = (video.clientWidth - video.videoWidth * scaleX) / 2;
    }

    for (const d of dets) {
        if (d.confidence < filterConf) continue;
        if (filterClasses.length > 0 && !filterClasses.includes(d.class)) continue;

        const x1 = d.x1 * scaleX + offsetX;
        const y1 = d.y1 * scaleY + offsetY;
        const x2 = d.x2 * scaleX + offsetX;
        const y2 = d.y2 * scaleY + offsetY;
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const id = d.id;

        trackingLines[id] = trackingLines[id] || []
        trackingLines[id].push({x: centerX, y: centerY});
        if(trackingLines[id].length > 20)trackingLines[id].shift()

        if (!objectTracks[id] || objectTracks[id].lastFrameId > nearestFrame) objectTracks[id] = {
            crossedA: false,
            crossedB: false,
            frameA: null,
            frameB: null,
            speed: null,
            lastFrameId: null,
            lastY: null
        };





        
        const track = objectTracks[id];

        if(track.lastY && track.lastFrameId < nearestFrame) {
            if((track.lastY < lineAY && lineAY < centerY) || (track.lastY > lineAY && lineAY > centerY)) {
                track.crossedA = true
                track.frameA = nearestFrame;
                // console.log(`ID: ${id}, A ${nearestFrame}`)
            }

            if((track.lastY < lineBY && lineBY < centerY) || (track.lastY > lineBY && lineBY > centerY)) {
                track.crossedB = true
                track.frameB = nearestFrame;
                // console.log(`ID: ${id}, B ${nearestFrame}`)
            }
        }



        // Maintain last Y positions
        track.lastY = centerY;
        track.lastFrameId = nearestFrame;


        // find plate number if exist
        // const plateNumberFrameData = plateNumberData[id]
        let plate_number = carPlateMap[id]?.value || ''
        
        // if(plateNumberFrameData) {
        //     const currentItem = plateNumberFrameData.find(x => x.parent == id)
        //     if(currentItem){
        //         plate_number = currentItem.value
        //         // console.log(plate_number)
        //         track.plate_number = carPlateMap[currentItem.parent] || plate_number
        //     }
        // }
        // plate_number = track.plate_number  || ''
        

        if(!platesMemo[plate_number] && plate_number) {
            platesMemo[plate_number] = true
            const plateList = document.getElementById("plateList");
            const li = document.createElement("li");
            li.style.cursor = 'pointer'
            li.textContent = `Identified Number plate: ${plate_number}`;
            li.onclick = () => {
                const plate_text = carPlateMap[id]
                console.log(plate_text)
                video.currentTime = parseInt(plate_text.frame) / fps
            }
            plateList.appendChild(li);
        }


        // Generate trails
        if(showTrackingEl.checked && trackingLines[id] && trackingLines[id].length > 1) {
            const points = trackingLines[id]
            drawLine(ctx, points, { color: 'tomato', width: 3 });
        }



        // --- Compute speed only once ---
        if (track.crossedA && track.crossedB && track.speed === null && lineDistMeters > 0) {
            const frameDiff = Math.abs(track.frameB - track.frameA);
            const timeSec = frameDiff / fps;
            if (timeSec != 0) { 
                track.speed = (lineDistMeters / timeSec) * 3.6; // m/s
                // console.log(`ID: ${id}, speed: ${track.speed}`)
                console.log(`${id} speed: ${track.speed.toFixed(2)} time: ${video.currentTime}`)
            }
            
        }

        // --- Pick box color ---
        let color = "lime";
        if ((track.crossedA && !track.crossedB) || (track.crossedB && !track.crossedA)) color = "blue";
        else if (track.crossedA && track.crossedB) color = "yellow";




        // if(track.speed || track.crossedA || track.crossedB) {
        // Draw box only if plate number is known
        if(!hideBoundingBox.checked) {
            // --- Draw box ---
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5; // thinner lines
            ctx.globalAlpha = 0.7; // slight transparency
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            ctx.globalAlpha = 1.0; // reset alpha for text
        }

        // if(track.speed) {
        // if(plate_number) {
            // --- Label ---
            let label = `${plate_number || d.class ||''}`
            if(track.speed) label += ` ${(track.speed).toFixed(2)} km/h`;
            const textWidth = ctx.measureText(label).width + 6;
            ctx.fillStyle = "rgba(255,255,255,0.6)"; // slightly transparent background
            ctx.fillRect(x1, y1 - 18, textWidth, 18);

            ctx.fillStyle = "black";
            ctx.font = "13px monospace"; // slightly smaller font for thin boxes
            ctx.fillText(label, x1 + 3, y1 - 5);
        // }

        if (track.crossedA && track.crossedB && track.speed !== null && !listed.has(id)) {
            // Mark as listed so we donâ€™t add it multiple times
            listed.add(id)

            const crossingList = document.getElementById("crossingList");
            const li = document.createElement("li");
            // li.textContent = `ID: ${plate_number || id}, Speed: ${(track.speed).toFixed(2)} km/h, Time: ${video.currentTime.toFixed(2)} s`;
            li.textContent = `ID: ${plate_number || id}, Speed: ${(track.speed).toFixed(2)} km/h`;
            crossingList.appendChild(li);
        }

        if (showPlatesCheckbox.checked) {
            const plates = plateData[nearestFrame] || []
            for(const plate of plates) {


                const x1 = plate.x1 * scaleX + offsetX;
                const y1 = plate.y1 * scaleY + offsetY;
                const x2 = plate.x2 * scaleX + offsetX;
                const y2 = plate.y2 * scaleY + offsetY;

                ctx.strokeStyle = 'green';
                ctx.lineWidth = 1; // thinner lines
                ctx.globalAlpha = 0.7; // slight transparency
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }
        }



        
    }

    if (!video.paused && !video.ended) {
        requestAnimationFrame(drawOverlay);
    }
}



</script>
</body>
</html>
