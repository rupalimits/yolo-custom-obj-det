<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>YOLO</title>
<style>
body {
    margin:0;
    font-family:'Segoe UI',sans-serif;
    background:#f5f5f5;
    color:#222;
}
header {
    padding:20px;
    text-align:center;
    background:#fff;
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
}
h2 { margin:0; }

.container {
    display:flex;
    padding:20px;
    gap:20px;
}

#videoContainer {
    position:relative;
    height:700px;
    background:#000;
    border-radius:8px;
    overflow:hidden;
}

#video {
    width:100%;
    height:100%;
    object-fit:contain;
}

#overlay {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
}

/* draggable lines */
.line {
    position:absolute;
    left:0;
    width:100%;
    height:3px;
    cursor:ns-resize;
    z-index:5;
}
#lineA {
    background:red;
    top:300px;
}
#lineB {
    background:blue;
    top:400px;
}
.line-label {
    position:absolute;
    left:10px;
    color:white;
    font-weight:bold;
    font-size:13px;
    text-shadow:0 0 3px black;
    pointer-events:none;
}

.rightBar {
    width: 350px;
    background:#fff;
    border-radius:8px;
    padding:15px;
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
    display:flex;
    flex-direction:column;
    gap:15px;
}
input[type=range] { width:100%; }
label { font-size:14px;font-weight:600; }

#progressBar {
    width:100%;
    height:12px;
    background:#ddd;
    border-radius:6px;
    overflow:hidden;
    margin:10px 0;
}
#progressFill {
    height:100%;
    width:0;
    background:#4caf50;
    transition:width 0.2s;
}

button {
    padding:8px 12px;
    background:#4caf50;
    color:white;
    border:none;
    border-radius:4px;
    cursor:pointer;
}
button:hover { background:#45a049; }

input[type=text], input[type=number] {
    width:100%;
    padding:6px;
    border:1px solid #ccc;
    border-radius:4px;
}
</style>

<style>
/* --- Crossing list UI --- */
#crossingList {
    list-style: none;        /* Remove bullets */
    padding: 0;              /* Remove default padding */
    margin: 0;               /* Remove default margin */
    max-height: 200px;       /* Scrollable if too long */
    overflow-y: auto;
    font-family: monospace;  /* Fixed-width for numbers */
    background: #fff;        /* White background */
    border: 1px solid #ccc;  /* Light border */
    border-radius: 6px;
    padding: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#crossingList li {
    padding: 4px 6px;
    border-bottom: 1px solid #eee;
    font-size: 13px;
}

#crossingList li:last-child {
    border-bottom: none; /* Remove bottom border on last item */
}





/* --- Styled file input button --- */
.file-btn {
    display: inline-block;
    padding: 8px 15px;
    background: #4caf50;
    color: white;
    font-weight: 600;
    border-radius: 6px;
    cursor: pointer;
    text-align: center;
    transition: background 0.2s;
}
.file-btn:hover {
    background: #45a049;
}
.file-btn:active {
    background: #3e8e41;
}


</style>

</head>
<body>
<header>
    <h2>YOLO Replay</h2>
</header>

<div class="container">
  <div style="flex:1;display:flex;flex-direction:column;">
    <div id="videoContainer">
      <video id="video" controls></video>
      <canvas id="overlay"></canvas>

      <!-- Draggable lines -->
      <div id="lineA" class="line"><span class="line-label"></span></div>
      <div id="lineB" class="line"><span class="line-label"></span></div>
    </div>

    <div style="padding:1.5rem;">
      <div id="progressBar"><div id="progressFill"></div></div>
      <p id="statusText">Waiting for upload...</p>
    </div>
  </div>

  <div class="rightBar">

    <!-- ðŸŽ¥ Select both video and CSV -->
    <label for="fileInput" class="file-btn">Select Video</label>
    <input type="file" id="fileInput" accept="video/*" style="display:none">

    <label for="csvInput" class="file-btn" style="margin-top:8px;">Select CSV</label>
    <input type="file" id="csvInput" accept=".csv" style="display:none">

    <button id="preloadBtn">Preload Video + CSV</button>

    <!-- Keep your existing UI controls -->
    <div>
      <label for="confSlider">Confidence Threshold: <span id="confValue">0.5</span></label>
      <input type="range" id="confSlider" min="0" max="1" step="0.05" value="0.5">
    </div>
    <div>
      <label for="classFilter">Filter Classes (comma-separated)</label>
      <input type="text" id="classFilter" placeholder="person,car,bike">
    </div>
    <div>
      <label for="lineDistance">Distance between lines (meters)</label>
      <input type="number" id="lineDistance" value="10" min="0" step="0.1">
    </div>
    <div>
      <input type="checkbox" id="showPlates">
      <label for="showPlates">Show License Plate Boxes</label>
    </div>

    <div style="margin-top:15px;">
      <h3>Vehicles Crossing Lines</h3>
      <ul id="crossingList"></ul>
    </div>
  </div>
</div>


<script>
const fileInput = document.getElementById("fileInput");
const csvInput = document.getElementById("csvInput");
const preloadBtn = document.getElementById("preloadBtn");
const video = document.getElementById("video");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const progressFill = document.getElementById("progressFill");
const statusText = document.getElementById("statusText");
const confSlider = document.getElementById("confSlider");
const confValue = document.getElementById("confValue");
const classFilter = document.getElementById("classFilter");
const lineA = document.getElementById("lineA");
const lineB = document.getElementById("lineB");
const lineDistanceInput = document.getElementById("lineDistance");
const showPlatesCheckbox = document.getElementById("showPlates");

let csvData = {};   // { frameNum: [ {id, class, confidence, x1,y1,x2,y2} ] }
let totalFrames = 0;
let processedFrames = 0;
let filterConf = parseFloat(confSlider.value);
let filterClasses = [];
let objectTracks = {};
let listed = new Set();

lineA.style.top = '300px';
lineB.style.top = '400px';

confSlider.oninput = () => {
  filterConf = parseFloat(confSlider.value);
  confValue.innerText = filterConf.toFixed(2);
};
classFilter.oninput = () => {
  filterClasses = classFilter.value.split(",").map(s=>s.trim()).filter(Boolean);
};

// ðŸ†• --- CSV Preload Logic ---
preloadBtn.onclick = async () => {
  const videoFile = fileInput.files[0];
  const csvFile = csvInput.files[0];
  if (!videoFile || !csvFile) {
    alert("Please select both a video and a CSV file.");
    return;
  }

  // Load and parse CSV
  statusText.innerText = "Loading CSV data...";
  csvData = await parseCSVFile(csvFile);
  totalFrames = Math.max(...Object.keys(csvData).map(Number));
  processedFrames = totalFrames;
  progressFill.style.width = "100%";
  statusText.innerText = `CSV loaded (${totalFrames} frames). Loading video...`;

  // Load video
  video.src = URL.createObjectURL(videoFile);
  setupVideo();
  statusText.innerText = "Ready to play!";
};

// ðŸ§© CSV parser (simple, no external libs)
async function parseCSVFile(file) {
  const text = await file.text();
  const lines = text.trim().split("\n");
  const headers = lines[0].split(",");
  const data = {};

  for (let i = 1; i < lines.length; i++) {
    const row = lines[i].split(",");
    const record = {};
    headers.forEach((h, j) => record[h.trim()] = parseFloat(row[j]) || row[j]);
    const f = parseInt(record.frame);
    if (!data[f]) data[f] = [];
    data[f].push({
      id: parseInt(record.id),
      class: record.class,
      confidence: parseFloat(record.confidence),
      x1: parseFloat(record.x1),
      y1: parseFloat(record.y1),
      x2: parseFloat(record.x2),
      y2: parseFloat(record.y2)
    });
  }
  return data;
}

// Setup canvas + overlay drawing
function setupVideo() {
  function resizeCanvas() {
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  video.addEventListener("seeked", drawOverlay);
  video.addEventListener("play", ()=>requestAnimationFrame(drawOverlay));
  video.addEventListener("pause", drawOverlay);
}

// ðŸŽ¨ Drawing logic (unchanged from your existing function)
function drawOverlay() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!csvData || Object.keys(csvData).length === 0) return;

  const allFrames = Object.keys(csvData).map(Number);
  const maxFrame = Math.max(...allFrames);
  const fps = maxFrame / video.duration;
  const approxFrame = Math.floor(video.currentTime * fps);
  const nearestFrame = allFrames.reduce((a,b)=>Math.abs(b-approxFrame)<Math.abs(a-approxFrame)?b:a);
  const dets = csvData[nearestFrame];
  if (!dets) return;

  const lineAY = parseFloat(lineA.style.top);
  const lineBY = parseFloat(lineB.style.top);
  const lineDistMeters = parseFloat(lineDistanceInput.value) || 0;

  // scale to display
  const videoAspect = video.videoWidth / video.videoHeight;
  const containerAspect = video.clientWidth / video.clientHeight;
  let scaleX, scaleY, offsetX=0, offsetY=0;
  if (videoAspect > containerAspect) {
    scaleX = video.clientWidth / video.videoWidth;
    scaleY = scaleX;
    offsetY = (video.clientHeight - video.videoHeight * scaleY) / 2;
  } else {
    scaleY = video.clientHeight / video.videoHeight;
    scaleX = scaleY;
    offsetX = (video.clientWidth - video.videoWidth * scaleX) / 2;
  }

  for (const d of dets) {
    if (d.confidence < filterConf) continue;
    if (filterClasses.length && !filterClasses.includes(d.class)) continue;

    const x1 = d.x1 * scaleX + offsetX;
    const y1 = d.y1 * scaleY + offsetY;
    const x2 = d.x2 * scaleX + offsetX;
    const y2 = d.y2 * scaleY + offsetY;
    const centerY = (y1 + y2)/2;
    const id = d.id;

    if (!objectTracks[id]) {
      objectTracks[id] = {crossedA:false,crossedB:false,frameA:null,frameB:null,speed:null,lastY:null,lastFrameId:null};
    }
    const track = objectTracks[id];

    if (track.lastY && track.lastFrameId < nearestFrame) {
      if ((track.lastY < lineAY && lineAY < centerY) || (track.lastY > lineAY && lineAY > centerY)) {
        track.crossedA = true; track.frameA = nearestFrame;
      }
      if ((track.lastY < lineBY && lineBY < centerY) || (track.lastY > lineBY && lineBY > centerY)) {
        track.crossedB = true; track.frameB = nearestFrame;
      }
    }

    track.lastY = centerY;
    track.lastFrameId = nearestFrame;

    if (track.crossedA && track.crossedB && track.speed === null && lineDistMeters>0) {
      const frameDiff = Math.abs(track.frameB - track.frameA);
      const timeSec = frameDiff / fps;
      if (timeSec>0) track.speed = (lineDistMeters/timeSec)*3.6;
    }

    let color = "lime";
    if ((track.crossedA && !track.crossedB) || (track.crossedB && !track.crossedA)) color="blue";
    else if (track.crossedA && track.crossedB) color="yellow";

    if (track.crossedA || track.crossedB) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.7;
      ctx.strokeRect(x1, y1, x2-x1, y2-y1);
      ctx.globalAlpha = 1;
    }

    if (track.speed && !listed.has(id)) {
      listed.add(id);
      const li = document.createElement("li");
      li.textContent = `ID:${id} Speed:${track.speed.toFixed(2)} km/h`;
      document.getElementById("crossingList").appendChild(li);
    }
  }

  if (!video.paused && !video.ended) requestAnimationFrame(drawOverlay);
}
</script>


</body>
</html>
